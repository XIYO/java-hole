# JAVASCRIPT

자바스크립트와 자바의 문법을 비교하며 설명합니다!

## 자바스크립트가 자바와 다른 점

### 메인 함수가 없어도 실행가능하다

자바스크립트는 설계 당시에 문법적 제약을 상당히 느슨하게 만들었다.
그래서 자바 처럼 메인 함수가 없어도 실행이 가능하다.

**자바**

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

> 자바는 OOP 를 충실히 따르기 위해 클래스의 정적 메서드로 메인 함수가 있어야 JVM 에서 실행가능하다. 
> 
> 컴파일되고 기계어로 번역되면 이러한 문법 구조는 아무런 의미가 없지만 자바는 통일을 위해서 이러한 문법으로만 실행가능하다.

**자바스크립트**

```javascript
console.log("Hello, World!");
```

> 자바스크립트는 단순히 함수, 메서드만 선언하는 것으로 즉시 실행이 가능하다.

### 타입이 없다

자바스크립트는 타입이 없다. 변수를 선언할 때 타입을 명시하지 않는다.
타입 제약이 없어서 변수에 모든 타입을 넣을 수 있고, 프로그램이 실행되면서 타입을 확신할 수가 없어 엄청난 버그를 유발 했다.

> 사실 자바스크립트 쓰다보면 클래스 만들다가 "아, 이게 디지털 노가다구나..."라고 깨닫고 타입 없는 자바스크립트가 젤 편한지 알게된다.
> 
> by 자바스크립트 사용자

**예시1**
    
```javascript   
var a = "Hello, World!"; // 개발자 A 가 변수 a 를 만들고 헬로 월드를 넣었다.
//  100만 줄의 코드...
var a = 1; // 개발자 B 가 변수 a 가 위에 있는지 모르고 다시 변수 a를 생성하고 1을 넣었다.
var b = 1;

var c = add(a, b); // 개발자 B 는 자신이 원하는 계산을 다했다.

// 100만 줄의 코드...
console.log(a); // 다시 개발자 A 가 이어서 작업하면서, 헬로 월드를 출력하려고했지만 1이 출력된다.

// 개발자 B 가 만든 더하기 함수
function add(a, b) {
    // 다른 개발자가 숫자가 아닌 타입을 넣을 수 있어 매번 검사해야한다...
    // 자바는 이러한 타입 체크가 필요 없다.
    if (typeof a !== 'number' || typeof b !== 'number') {
        throw new Error('a, b must be number');
    }
    
    return a + b;
}
```

결국, 타입이 없는 것이 독이었지만 이미 자바스크립트로 지구 전체의 웹 생태계가 만들어져서 어쩔 수 없이 쓰고 있다.

**똑같은 변수 생성 제한 방법**

```javascript
var a = 1;
var a = 2; // 같은 이름으로 변수 선언 가능

let b = 1;
let b = 2; // 같은 이름으로 변수 선언 불가
```

> 자바스크립트가 최초에 나왔을 때는 `var` 로 변수를 선언했지만 중복으로 선언해도 아무런 문제가 발생하지 않아,
> 런타임에 변수가 바뀌는 일이 잦았고, 웹 개발자에게 엄청난 고통을 주었다.
> 
> 그래서 ES6 에서 `let` 이라는 변수 선언 키워드를 추가했다. `let` 은 같은 블록에서 같은 이름의 변수를 선언할 수 없다.

### 자바스크립트도 객체 지향 형식으로 코딩이 가능하다

자바는 객제 지향 언어다. 
그래서 객체 지향이라는 패러다임에 맞게 모든것을 클래스로 선언하고 클래스를 인스턴스화 해서 사용한다는 느낌이 들게 
문법적으로 그렇게 강제하도록 했다.

그래서 대표적인 예로 클래스안에 또 스태틱 `Main` 메서드를 만들어서 실행해야한다.

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

> 단순히 실행하나 하려고해도 
> 1. 클래스 만들고
> 2. 메서드 만들고 
> 3. 메서드를 정적으로 바꿔야하고
>
> 매우 따분한 코드가 나온다.

자바스크립트는 이와 다르게 문법에서 객체 지향을 강요하지 않는다.

**예시1, 단순 함수 생성**

자바에서는 헬로 하나 출력하기 위해서 클래스, 메서드를 꼭 만들어야 하는데, 자바스크립트는 함수 하나로 가능하다.

> 자바스크립트에 익숙해 져서 🍯 처럼 코딩하다가, 자바가서 클래스 만들고 메서드 만들고 하면 세상 불편하다.
> 
> 겨우 함수 하나 만드는데 클래스 까지 만들어야하다니!!!(그래서 람다가 나왔는데, 편리성은 자바스크립트만 못하다)

```javascript
function hello() {
    console.log("Hello, World!");
}

hello();
```

> 옛날에는 함수를 위에 선언해서 개발자가 코드의 윗 부분만 읽으면 이 코드가 가진 함수가 뭔지 다 파악할 수 있게 작성하는게 국룰이었다.
> 즉, 등장인물 먼저 설명하고, 소설이 시작된다.

```javascript
hello();

function hello() {
    console.log("Hello, World!");
}
```

> 요세는 IDE 가 좋아서 컨트롤 클릭 한방에 함수의 본체로 갈 수 있어서, 소설이 먼저 나오고, 등장인물은 맨 뒤에 넣어둔다. 

**예시2, 객체 생성**

자바에서는 클래스 문법으로 붕어빵 틀을 만들고, 자바스크립트에서는 프로토타입 문법으로 붕어빵 틀을 만든다. 

**자바**

```java
public class Main {
    public static void main(String[] args) {
        Student student = new Student("홍길동", 20);
        student.name ="킹길동"; // 개명해서 학생 이름 바꿈, 퍼블릭 변수라서 바로 대입한다.
        student.setAge(21); // 나이 세는 법이 바뀌어서 나이를 바꿈, 프라이빗 변수라서 세터 메서드로 변경해야한다.
    }
}

class Student {
    public String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    static void upgrade() {
        this.age++;
    }

    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
}


```

> 자바도 나쁘지 않은 문법이다.

**자바스크립트**

```javascript
var s1 = new Student("홍길동", 20);
s1.name = "킹길동"; // 개명해서 학생 이름 바꿈, 퍼블릭 변수라서 바로 대입한다.
s1.#age = 21; 

// 함수라고 선언하지만 객체를 만들기 위한 붕어빵 틀, 생성자 함수를 바로 만든다.
function Student(name, age) {
    this.name = name;
    this.#age = age; // 자바스크립트는 접근제어자가 없어서 변수 앞에 언더바를 붙여서 프라이빗 변수라고 표시한다.
    
    //  #age 의 _(언더바)는 이런 느낌이다.
    this.인스턴스의필드에바로값을대입하지말고메서드가있으면그걸로변경하세요age = age;
}

// 자바의 클래스 문법에 비유하면 클래스 메서드 즉, "static void upgrade() {}" 와 같다. 
Student.upgrade = function() {
    this._age++;
}

// 프로토타입은 자바에서 비유하면 인스턴스 메서드와 똑같다. 즉, "int getAge() { return this.age;}"와 같다. (인스턴스 변수)
Student.prototype.getAge = function() {
    return this.#age;
}

Student.prototype.setAge = function(age) {
    this.#age = age;
}
```

> 자바랑 자바스크립트는 똑같은, 객제 지향을 흉내낼수 있는 언어지만 각자 표현하는 문법이 다를 뿐이다.


**자바스크립트에서 클래스 문법 사용**

최신 버전의 자바스크립트에서는 클래스 문법을 지원해준다!   
왜냐하면 프로토타입 문법이 난해하기 때문에 자바스크립트 제단이 한수 접고 클래스 문법도 허용해줬다!

```javascript
class Student {
    
    // name; 공개 변수는 생성자에서 생성해도 된다.
    #age; // 프라이빗 변수는 #을 붙인다.
    
    // 자바스크립트도 자바와 같이 생성자가 있으며, 생성자는 클래스의 이름이 아니라 constructor 라는 키워드로 만든다.
    constructor(name, age) {
        this.name = name; // 클래스 내부에 name 변수가 선언되지 않아도 여기서 this.name에 값을 넣으면 생성된다.(나중에 에러뜨기 딱 좋음)
        this.#age = age; // 그러나 프라이빗 변수는 반드시 클래스 내부에 미리 선언하고 값을 대입해야한다.
    }

    // 자바와 마찬가지로 스태틱 키워드로 스태틱 메서드를 만들 수 있다.
    // 다만 반환 타입 같은건 필요없다.
    static upgrade() {
        this.#age++;
    }

    // 클래스 내부에서는 함수를 만들때 function 키워드가 필요 없고, 이름() {} 이런 형식으로 만들면 그게 곧 함수다.
    getAge() {
        return this.#age;
    }

    setAge(age) {
        this.#age = age;
    }
}
```

**번외, 클로저로 프라이빗 변수 만들기**

자바스크립트는 최신 문법인 클래스 문법이 아니면 프라이빗 변수를 만들 수 없다.   
그래서 어떻게든 프라이빗 변수를 만들고 싶었던 개발자가 만들어넨 테크닉이 클로저 방식이다.

클로저 뜻은 "닫힌" 이라는 뜻으로, 변수를 외부에서 참조하지 못 하게, 내부에서만 참조가능하도록 닫아버려서 프라이빗 변수처럼 사용하는 방법이다. 

```javascript
function myClosure() {
    var a = 1; // 함수안에 변수를 하나 선언

    // 함수의 실행 결과가 함수를 리턴한다.... 자바스크립트라서 가능한 문법
    return function() {
        console.log(++a); // 반환하는 함수 안에 변수 a를 참조하여 콘솔 로그에 출력하는 명령어가 계속해서 a의 주소 값을 알고 있다.  
    }
}

// 클로저의 사용
var c = myClosure(); // 이 함수의 실행 결과는 함수다.
c(); // 그래서 c는 함수가 담겨 있기 때문에 괄호를 사용해서 실행할 수 있다. 자바 였다면 꿈도 못꾼다. 앙꿈못띠
```